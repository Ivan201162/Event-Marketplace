# üí≥ –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –ø–ª–∞—Ç–µ–∂–Ω—ã—Ö —à–ª—é–∑–æ–≤

## üìÖ –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è
**3 –æ–∫—Ç—è–±—Ä—è 2025 –≥–æ–¥–∞**

## üéØ –¶–µ–ª—å
–ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–ª–∞—Ç–µ–∂–Ω—ã–µ —à–ª—é–∑—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–ª–∞—Ç–µ–∂–µ–π –≤ Event Marketplace App.

## üè¶ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –ø–ª–∞—Ç–µ–∂–Ω—ã–µ —Å–∏—Å—Ç–µ–º—ã

### 1. üí≥ Stripe
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è
- **–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**: 
  - –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞
  - –ù–∏–∑–∫–∏–µ –∫–æ–º–∏—Å—Å–∏–∏
  - –û—Ç–ª–∏—á–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
  - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –≤–∞–ª—é—Ç

### 2. üí∞ PayPal
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è
- **–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
  - –í—ã—Å–æ–∫–æ–µ –¥–æ–≤–µ—Ä–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
  - –ü—Ä–æ—Å—Ç–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
  - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ PayPal –∏ –∫—Ä–µ–¥–∏—Ç–Ω—ã—Ö –∫–∞—Ä—Ç

### 3. üè¶ –ÆKassa (–Ø–Ω–¥–µ–∫—Å.–ö–∞—Å—Å–∞)
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –î–ª—è –†–æ—Å—Å–∏–∏
- **–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
  - –õ–æ–∫–∞–ª—å–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞
  - –ù–∏–∑–∫–∏–µ –∫–æ–º–∏—Å—Å–∏–∏ –≤ –†–æ—Å—Å–∏–∏
  - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä–æ—Å—Å–∏–π—Å–∫–∏—Ö –∫–∞—Ä—Ç

### 4. üíé –°–±–µ—Ä–±–∞–Ω–∫
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –î–ª—è –†–æ—Å—Å–∏–∏
- **–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
  - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –°–±–µ—Ä–±–∞–Ω–∫–æ–º
  - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –°–ë–ü (–°–∏—Å—Ç–µ–º–∞ –±—ã—Å—Ç—Ä—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π)

## üöÄ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Stripe

### 1. üîë –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Stripe

#### 1.1 –°–æ–∑–¥–∞–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞
```bash
# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–∞ https://stripe.com
# –ü–æ–ª—É—á–µ–Ω–∏–µ API –∫–ª—é—á–µ–π:
# - Publishable key (pk_live_...)
# - Secret key (sk_live_...)
# - Webhook secret (whsec_...)
```

#### 1.2 –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
```yaml
# pubspec.yaml
dependencies:
  flutter_stripe: ^10.1.1
  http: ^1.1.0
```

#### 1.3 –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
```dart
// lib/config/stripe_config.dart
class StripeConfig {
  static const String publishableKey = 'pk_live_your_publishable_key';
  static const String secretKey = 'sk_live_your_secret_key';
  static const String webhookSecret = 'whsec_your_webhook_secret';
  
  // –¢–µ—Å—Ç–æ–≤—ã–µ –∫–ª—é—á–∏ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
  static const String testPublishableKey = 'pk_test_your_test_publishable_key';
  static const String testSecretKey = 'sk_test_your_test_secret_key';
  
  static String get currentPublishableKey {
    return kDebugMode ? testPublishableKey : publishableKey;
  }
}
```

### 2. üí≥ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ

#### 2.1 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Stripe
```dart
// lib/main.dart
import 'package:flutter_stripe/flutter_stripe.dart';
import 'config/stripe_config.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Stripe
  Stripe.publishableKey = StripeConfig.currentPublishableKey;
  
  runApp(MyApp());
}
```

#### 2.2 –°–µ—Ä–≤–∏—Å –ø–ª–∞—Ç–µ–∂–µ–π
```dart
// lib/services/stripe_payment_service.dart
import 'package:flutter_stripe/flutter_stripe.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import '../config/stripe_config.dart';

class StripePaymentService {
  static const String _baseUrl = 'https://api.stripe.com/v1';
  
  /// –°–æ–∑–¥–∞—Ç—å PaymentIntent
  Future<PaymentIntent> createPaymentIntent({
    required double amount,
    required String currency,
    required String customerId,
    Map<String, dynamic>? metadata,
  }) async {
    final response = await http.post(
      Uri.parse('$_baseUrl/payment_intents'),
      headers: {
        'Authorization': 'Bearer ${StripeConfig.secretKey}',
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: {
        'amount': (amount * 100).toInt().toString(), // Stripe –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∫–æ–ø–µ–π–∫–∏
        'currency': currency,
        'customer': customerId,
        'metadata': metadata != null ? jsonEncode(metadata) : null,
        'automatic_payment_methods[enabled]': 'true',
      },
    );
    
    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return PaymentIntent.fromJson(data);
    } else {
      throw Exception('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è PaymentIntent: ${response.body}');
    }
  }
  
  /// –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ø–ª–∞—Ç–µ–∂
  Future<PaymentIntent> confirmPayment({
    required String paymentIntentId,
    required String paymentMethodId,
  }) async {
    try {
      final paymentIntent = await Stripe.instance.confirmPayment(
        paymentIntentId,
        PaymentMethodParams.card(
          paymentMethodData: PaymentMethodData(
            billingDetails: BillingDetails(),
          ),
        ),
      );
      
      return paymentIntent;
    } catch (e) {
      throw Exception('–û—à–∏–±–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞: $e');
    }
  }
  
  /// –°–æ–∑–¥–∞—Ç—å –∫–ª–∏–µ–Ω—Ç–∞
  Future<Map<String, dynamic>> createCustomer({
    required String email,
    required String name,
    String? phone,
  }) async {
    final response = await http.post(
      Uri.parse('$_baseUrl/customers'),
      headers: {
        'Authorization': 'Bearer ${StripeConfig.secretKey}',
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: {
        'email': email,
        'name': name,
        'phone': phone,
      },
    );
    
    if (response.statusCode == 200) {
      return jsonDecode(response.body);
    } else {
      throw Exception('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞: ${response.body}');
    }
  }
  
  /// –°–æ–∑–¥–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫—É
  Future<Map<String, dynamic>> createSubscription({
    required String customerId,
    required String priceId,
    Map<String, dynamic>? metadata,
  }) async {
    final response = await http.post(
      Uri.parse('$_baseUrl/subscriptions'),
      headers: {
        'Authorization': 'Bearer ${StripeConfig.secretKey}',
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: {
        'customer': customerId,
        'items[0][price]': priceId,
        'metadata': metadata != null ? jsonEncode(metadata) : null,
        'payment_behavior': 'default_incomplete',
        'payment_settings[save_default_payment_method]': 'on_subscription',
        'expand[]': 'latest_invoice.payment_intent',
      },
    );
    
    if (response.statusCode == 200) {
      return jsonDecode(response.body);
    } else {
      throw Exception('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏: ${response.body}');
    }
  }
}
```

#### 2.3 –í–∏–¥–∂–µ—Ç –æ–ø–ª–∞—Ç—ã
```dart
// lib/widgets/stripe_payment_widget.dart
import 'package:flutter/material.dart';
import 'package:flutter_stripe/flutter_stripe.dart';
import '../services/stripe_payment_service.dart';

class StripePaymentWidget extends StatefulWidget {
  final double amount;
  final String currency;
  final String customerId;
  final Function(PaymentIntent) onSuccess;
  final Function(String) onError;

  const StripePaymentWidget({
    super.key,
    required this.amount,
    required this.currency,
    required this.customerId,
    required this.onSuccess,
    required this.onError,
  });

  @override
  State<StripePaymentWidget> createState() => _StripePaymentWidgetState();
}

class _StripePaymentWidgetState extends State<StripePaymentWidget> {
  final StripePaymentService _paymentService = StripePaymentService();
  bool _isLoading = false;
  String? _error;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        if (_error != null)
          Container(
            padding: const EdgeInsets.all(16),
            margin: const EdgeInsets.only(bottom: 16),
            decoration: BoxDecoration(
              color: Colors.red.shade50,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: Colors.red.shade200),
            ),
            child: Row(
              children: [
                Icon(Icons.error, color: Colors.red.shade600),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    _error!,
                    style: TextStyle(color: Colors.red.shade600),
                  ),
                ),
              ],
            ),
          ),
        
        ElevatedButton(
          onPressed: _isLoading ? null : _processPayment,
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.blue.shade600,
            foregroundColor: Colors.white,
            padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8),
            ),
          ),
          child: _isLoading
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                    valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                  ),
                )
              : const Text('–û–ø–ª–∞—Ç–∏—Ç—å'),
        ),
      ],
    );
  }

  Future<void> _processPayment() async {
    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      // –°–æ–∑–¥–∞–Ω–∏–µ PaymentIntent
      final paymentIntent = await _paymentService.createPaymentIntent(
        amount: widget.amount,
        currency: widget.currency,
        customerId: widget.customerId,
        metadata: {
          'app': 'event_marketplace',
          'timestamp': DateTime.now().toIso8601String(),
        },
      );

      // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞
      final confirmedPayment = await _paymentService.confirmPayment(
        paymentIntentId: paymentIntent.id,
        paymentMethodId: paymentIntent.paymentMethodId ?? '',
      );

      if (confirmedPayment.status == PaymentIntentStatus.Succeeded) {
        widget.onSuccess(confirmedPayment);
      } else {
        widget.onError('–ü–ª–∞—Ç–µ–∂ –Ω–µ –±—ã–ª –∑–∞–≤–µ—Ä—à–µ–Ω');
      }
    } catch (e) {
      widget.onError('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–ª–∞—Ç–µ–∂–∞: $e');
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }
}
```

### 3. üîî Webhook –æ–±—Ä–∞–±–æ—Ç–∫–∞

#### 3.1 Cloud Function –¥–ª—è webhook
```javascript
// functions/stripe-webhook.js
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const stripe = require('stripe')(functions.config().stripe.secret_key);

exports.stripeWebhook = functions.https.onRequest(async (req, res) => {
  const sig = req.headers['stripe-signature'];
  const endpointSecret = functions.config().stripe.webhook_secret;

  let event;

  try {
    event = stripe.webhooks.constructEvent(req.body, sig, endpointSecret);
  } catch (err) {
    console.log(`Webhook signature verification failed.`, err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏—è
  switch (event.type) {
    case 'payment_intent.succeeded':
      await handlePaymentSucceeded(event.data.object);
      break;
    case 'payment_intent.payment_failed':
      await handlePaymentFailed(event.data.object);
      break;
    case 'customer.subscription.created':
      await handleSubscriptionCreated(event.data.object);
      break;
    case 'customer.subscription.updated':
      await handleSubscriptionUpdated(event.data.object);
      break;
    case 'customer.subscription.deleted':
      await handleSubscriptionDeleted(event.data.object);
      break;
    default:
      console.log(`Unhandled event type ${event.type}`);
  }

  res.json({received: true});
});

async function handlePaymentSucceeded(paymentIntent) {
  const { metadata } = paymentIntent;
  
  if (metadata.bookingId) {
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
    await admin.firestore()
      .collection('bookings')
      .doc(metadata.bookingId)
      .update({
        paymentStatus: 'paid',
        paymentIntentId: paymentIntent.id,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });
  }
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –æ –ø–ª–∞—Ç–µ–∂–µ
  await admin.firestore()
    .collection('payments')
    .add({
      id: paymentIntent.id,
      amount: paymentIntent.amount / 100, // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –∏–∑ –∫–æ–ø–µ–µ–∫
      currency: paymentIntent.currency,
      status: 'completed',
      customerId: paymentIntent.customer,
      metadata: metadata,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
    });
}

async function handlePaymentFailed(paymentIntent) {
  const { metadata } = paymentIntent;
  
  if (metadata.bookingId) {
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
    await admin.firestore()
      .collection('bookings')
      .doc(metadata.bookingId)
      .update({
        paymentStatus: 'failed',
        paymentIntentId: paymentIntent.id,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });
  }
}

async function handleSubscriptionCreated(subscription) {
  // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏
  await admin.firestore()
    .collection('subscriptions')
    .doc(subscription.id)
    .set({
      id: subscription.id,
      customerId: subscription.customer,
      status: subscription.status,
      currentPeriodStart: new Date(subscription.current_period_start * 1000),
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
    });
}

async function handleSubscriptionUpdated(subscription) {
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏
  await admin.firestore()
    .collection('subscriptions')
    .doc(subscription.id)
    .update({
      status: subscription.status,
      currentPeriodStart: new Date(subscription.current_period_start * 1000),
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    });
}

async function handleSubscriptionDeleted(subscription) {
  // –£–¥–∞–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏
  await admin.firestore()
    .collection('subscriptions')
    .doc(subscription.id)
    .update({
      status: 'cancelled',
      cancelledAt: admin.firestore.FieldValue.serverTimestamp(),
    });
}
```

## üí∞ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è PayPal

### 1. üîë –ù–∞—Å—Ç—Ä–æ–π–∫–∞ PayPal

#### 1.1 –°–æ–∑–¥–∞–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞
```bash
# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–∞ https://developer.paypal.com
# –ü–æ–ª—É—á–µ–Ω–∏–µ API –∫–ª—é—á–µ–π:
# - Client ID
# - Client Secret
# - Webhook ID
```

#### 1.2 –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
```yaml
# pubspec.yaml
dependencies:
  paypal_sdk: ^1.0.0
  http: ^1.1.0
```

#### 1.3 –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
```dart
// lib/config/paypal_config.dart
class PayPalConfig {
  static const String clientId = 'your_paypal_client_id';
  static const String clientSecret = 'your_paypal_client_secret';
  static const String webhookId = 'your_paypal_webhook_id';
  
  // –¢–µ—Å—Ç–æ–≤—ã–µ –∫–ª—é—á–∏ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
  static const String testClientId = 'your_test_paypal_client_id';
  static const String testClientSecret = 'your_test_paypal_client_secret';
  
  static String get currentClientId {
    return kDebugMode ? testClientId : clientId;
  }
  
  static String get currentClientSecret {
    return kDebugMode ? testClientSecret : clientSecret;
  }
}
```

### 2. üí≥ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ

#### 2.1 –°–µ—Ä–≤–∏—Å PayPal
```dart
// lib/services/paypal_payment_service.dart
import 'package:http/http.dart' as http;
import 'dart:convert';
import '../config/paypal_config.dart';

class PayPalPaymentService {
  static const String _baseUrl = 'https://api.paypal.com/v1';
  static const String _testBaseUrl = 'https://api.sandbox.paypal.com/v1';
  
  String get baseUrl => kDebugMode ? _testBaseUrl : _baseUrl;
  
  /// –ü–æ–ª—É—á–∏—Ç—å —Ç–æ–∫–µ–Ω –¥–æ—Å—Ç—É–ø–∞
  Future<String> getAccessToken() async {
    final response = await http.post(
      Uri.parse('$baseUrl/oauth2/token'),
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Authorization': 'Basic ${base64Encode(utf8.encode('${PayPalConfig.currentClientId}:${PayPalConfig.currentClientSecret}'))}',
      },
      body: 'grant_type=client_credentials',
    );
    
    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['access_token'];
    } else {
      throw Exception('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞: ${response.body}');
    }
  }
  
  /// –°–æ–∑–¥–∞—Ç—å –∑–∞–∫–∞–∑
  Future<Map<String, dynamic>> createOrder({
    required double amount,
    required String currency,
    required String description,
    Map<String, dynamic>? metadata,
  }) async {
    final accessToken = await getAccessToken();
    
    final response = await http.post(
      Uri.parse('$baseUrl/checkout/orders'),
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer $accessToken',
      },
      body: jsonEncode({
        'intent': 'CAPTURE',
        'purchase_units': [
          {
            'amount': {
              'currency_code': currency,
              'value': amount.toStringAsFixed(2),
            },
            'description': description,
            'custom_id': metadata?['bookingId'],
          }
        ],
        'application_context': {
          'return_url': 'https://your-domain.com/payment/success',
          'cancel_url': 'https://your-domain.com/payment/cancel',
        },
      }),
    );
    
    if (response.statusCode == 201) {
      return jsonDecode(response.body);
    } else {
      throw Exception('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–∫–∞–∑–∞: ${response.body}');
    }
  }
  
  /// –ó–∞—Ö–≤–∞—Ç–∏—Ç—å –ø–ª–∞—Ç–µ–∂
  Future<Map<String, dynamic>> captureOrder(String orderId) async {
    final accessToken = await getAccessToken();
    
    final response = await http.post(
      Uri.parse('$baseUrl/checkout/orders/$orderId/capture'),
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer $accessToken',
      },
    );
    
    if (response.statusCode == 201) {
      return jsonDecode(response.body);
    } else {
      throw Exception('–û—à–∏–±–∫–∞ –∑–∞—Ö–≤–∞—Ç–∞ –ø–ª–∞—Ç–µ–∂–∞: ${response.body}');
    }
  }
}
```

## üè¶ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –ÆKassa

### 1. üîë –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ÆKassa

#### 1.1 –°–æ–∑–¥–∞–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞
```bash
# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–∞ https://yookassa.ru
# –ü–æ–ª—É—á–µ–Ω–∏–µ API –∫–ª—é—á–µ–π:
# - Shop ID
# - Secret Key
# - Webhook Secret
```

#### 1.2 –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
```yaml
# pubspec.yaml
dependencies:
  yookassa_flutter: ^1.0.0
  http: ^1.1.0
```

#### 1.3 –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
```dart
// lib/config/yookassa_config.dart
class YooKassaConfig {
  static const String shopId = 'your_shop_id';
  static const String secretKey = 'your_secret_key';
  static const String webhookSecret = 'your_webhook_secret';
  
  // –¢–µ—Å—Ç–æ–≤—ã–µ –∫–ª—é—á–∏ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
  static const String testShopId = 'your_test_shop_id';
  static const String testSecretKey = 'your_test_secret_key';
  
  static String get currentShopId {
    return kDebugMode ? testShopId : shopId;
  }
  
  static String get currentSecretKey {
    return kDebugMode ? testSecretKey : secretKey;
  }
}
```

### 2. üí≥ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ

#### 2.1 –°–µ—Ä–≤–∏—Å –ÆKassa
```dart
// lib/services/yookassa_payment_service.dart
import 'package:http/http.dart' as http;
import 'dart:convert';
import '../config/yookassa_config.dart';

class YooKassaPaymentService {
  static const String _baseUrl = 'https://api.yookassa.ru/v3';
  static const String _testBaseUrl = 'https://api.yookassa.ru/v3';
  
  String get baseUrl => _baseUrl;
  
  /// –°–æ–∑–¥–∞—Ç—å –ø–ª–∞—Ç–µ–∂
  Future<Map<String, dynamic>> createPayment({
    required double amount,
    required String currency,
    required String description,
    required String returnUrl,
    Map<String, dynamic>? metadata,
  }) async {
    final response = await http.post(
      Uri.parse('$baseUrl/payments'),
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Basic ${base64Encode(utf8.encode('${YooKassaConfig.currentShopId}:${YooKassaConfig.currentSecretKey}'))}',
        'Idempotence-Key': DateTime.now().millisecondsSinceEpoch.toString(),
      },
      body: jsonEncode({
        'amount': {
          'value': amount.toStringAsFixed(2),
          'currency': currency,
        },
        'confirmation': {
          'type': 'redirect',
          'return_url': returnUrl,
        },
        'description': description,
        'metadata': metadata,
      }),
    );
    
    if (response.statusCode == 200) {
      return jsonDecode(response.body);
    } else {
      throw Exception('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞: ${response.body}');
    }
  }
  
  /// –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–ª–∞—Ç–µ–∂–µ
  Future<Map<String, dynamic>> getPayment(String paymentId) async {
    final response = await http.get(
      Uri.parse('$baseUrl/payments/$paymentId'),
      headers: {
        'Authorization': 'Basic ${base64Encode(utf8.encode('${YooKassaConfig.currentShopId}:${YooKassaConfig.currentSecretKey}'))}',
      },
    );
    
    if (response.statusCode == 200) {
      return jsonDecode(response.body);
    } else {
      throw Exception('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞: ${response.body}');
    }
  }
}
```

## üîÑ –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–∏—Å –ø–ª–∞—Ç–µ–∂–µ–π

### 1. üéØ –ê–±—Å—Ç—Ä–∞–∫—Ü–∏—è –ø–ª–∞—Ç–µ–∂–µ–π

#### 1.1 –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø–ª–∞—Ç–µ–∂–Ω–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
```dart
// lib/services/payment_service_interface.dart
abstract class PaymentServiceInterface {
  Future<PaymentResult> processPayment({
    required double amount,
    required String currency,
    required String description,
    required String customerId,
    Map<String, dynamic>? metadata,
  });
  
  Future<PaymentResult> getPaymentStatus(String paymentId);
  Future<bool> refundPayment(String paymentId, double amount);
}

class PaymentResult {
  final String paymentId;
  final PaymentStatus status;
  final String? redirectUrl;
  final String? errorMessage;
  final Map<String, dynamic>? metadata;
  
  const PaymentResult({
    required this.paymentId,
    required this.status,
    this.redirectUrl,
    this.errorMessage,
    this.metadata,
  });
}

enum PaymentStatus {
  pending,
  processing,
  completed,
  failed,
  cancelled,
  refunded,
}
```

#### 1.2 –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–∏—Å –ø–ª–∞—Ç–µ–∂–µ–π
```dart
// lib/services/universal_payment_service.dart
import 'payment_service_interface.dart';
import 'stripe_payment_service.dart';
import 'paypal_payment_service.dart';
import 'yookassa_payment_service.dart';

class UniversalPaymentService implements PaymentServiceInterface {
  final StripePaymentService _stripeService = StripePaymentService();
  final PayPalPaymentService _paypalService = PayPalPaymentService();
  final YooKassaPaymentService _yookassaService = YooKassaPaymentService();
  
  /// –í—ã–±—Ä–∞—Ç—å –ø–ª–∞—Ç–µ–∂–Ω—ã–π —Å–µ—Ä–≤–∏—Å
  PaymentServiceInterface _selectPaymentService(PaymentMethod method) {
    switch (method) {
      case PaymentMethod.stripe:
        return _stripeService;
      case PaymentMethod.paypal:
        return _paypalService;
      case PaymentMethod.yookassa:
        return _yookassaService;
      default:
        throw UnsupportedError('–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π –º–µ—Ç–æ–¥ –æ–ø–ª–∞—Ç—ã: $method');
    }
  }
  
  @override
  Future<PaymentResult> processPayment({
    required double amount,
    required String currency,
    required String description,
    required String customerId,
    required PaymentMethod method,
    Map<String, dynamic>? metadata,
  }) async {
    final service = _selectPaymentService(method);
    
    try {
      return await service.processPayment(
        amount: amount,
        currency: currency,
        description: description,
        customerId: customerId,
        metadata: metadata,
      );
    } catch (e) {
      return PaymentResult(
        paymentId: '',
        status: PaymentStatus.failed,
        errorMessage: e.toString(),
      );
    }
  }
  
  @override
  Future<PaymentResult> getPaymentStatus(String paymentId) async {
    // –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å–µ—Ä–≤–∏—Å –ø–æ ID –ø–ª–∞—Ç–µ–∂–∞
    final method = _detectPaymentMethod(paymentId);
    final service = _selectPaymentService(method);
    
    return await service.getPaymentStatus(paymentId);
  }
  
  @override
  Future<bool> refundPayment(String paymentId, double amount) async {
    final method = _detectPaymentMethod(paymentId);
    final service = _selectPaymentService(method);
    
    return await service.refundPayment(paymentId, amount);
  }
  
  /// –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –º–µ—Ç–æ–¥ –æ–ø–ª–∞—Ç—ã –ø–æ ID –ø–ª–∞—Ç–µ–∂–∞
  PaymentMethod _detectPaymentMethod(String paymentId) {
    if (paymentId.startsWith('pi_')) {
      return PaymentMethod.stripe;
    } else if (paymentId.startsWith('PAY-')) {
      return PaymentMethod.paypal;
    } else if (paymentId.startsWith('yookassa_')) {
      return PaymentMethod.yookassa;
    } else {
      throw UnsupportedError('–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ID –ø–ª–∞—Ç–µ–∂–∞: $paymentId');
    }
  }
}

enum PaymentMethod {
  stripe,
  paypal,
  yookassa,
  sberbank,
}
```

## üé® UI –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã

### 1. üí≥ –í–∏–¥–∂–µ—Ç –≤—ã–±–æ—Ä–∞ –º–µ—Ç–æ–¥–∞ –æ–ø–ª–∞—Ç—ã

#### 1.1 –í–∏–¥–∂–µ—Ç –≤—ã–±–æ—Ä–∞
```dart
// lib/widgets/payment_method_selector.dart
import 'package:flutter/material.dart';
import '../services/universal_payment_service.dart';

class PaymentMethodSelector extends StatefulWidget {
  final Function(PaymentMethod) onMethodSelected;
  final PaymentMethod? selectedMethod;

  const PaymentMethodSelector({
    super.key,
    required this.onMethodSelected,
    this.selectedMethod,
  });

  @override
  State<PaymentMethodSelector> createState() => _PaymentMethodSelectorState();
}

class _PaymentMethodSelectorState extends State<PaymentMethodSelector> {
  PaymentMethod? _selectedMethod;

  @override
  void initState() {
    super.initState();
    _selectedMethod = widget.selectedMethod;
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          '–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã',
          style: TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        
        ...PaymentMethod.values.map((method) => _buildPaymentMethodCard(method)),
      ],
    );
  }

  Widget _buildPaymentMethodCard(PaymentMethod method) {
    final isSelected = _selectedMethod == method;
    
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      elevation: isSelected ? 4 : 1,
      color: isSelected ? Colors.blue.shade50 : Colors.white,
      child: InkWell(
        onTap: () {
          setState(() {
            _selectedMethod = method;
          });
          widget.onMethodSelected(method);
        },
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Radio<PaymentMethod>(
                value: method,
                groupValue: _selectedMethod,
                onChanged: (value) {
                  setState(() {
                    _selectedMethod = value;
                  });
                  widget.onMethodSelected(value!);
                },
              ),
              const SizedBox(width: 12),
              _getPaymentMethodIcon(method),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      _getPaymentMethodName(method),
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                    Text(
                      _getPaymentMethodDescription(method),
                      style: TextStyle(
                        fontSize: 14,
                        color: Colors.grey.shade600,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _getPaymentMethodIcon(PaymentMethod method) {
    switch (method) {
      case PaymentMethod.stripe:
        return Container(
          width: 40,
          height: 40,
          decoration: BoxDecoration(
            color: Colors.blue.shade600,
            borderRadius: BorderRadius.circular(8),
          ),
          child: const Icon(
            Icons.credit_card,
            color: Colors.white,
            size: 24,
          ),
        );
      case PaymentMethod.paypal:
        return Container(
          width: 40,
          height: 40,
          decoration: BoxDecoration(
            color: Colors.blue.shade700,
            borderRadius: BorderRadius.circular(8),
          ),
          child: const Icon(
            Icons.payment,
            color: Colors.white,
            size: 24,
          ),
        );
      case PaymentMethod.yookassa:
        return Container(
          width: 40,
          height: 40,
          decoration: BoxDecoration(
            color: Colors.orange.shade600,
            borderRadius: BorderRadius.circular(8),
          ),
          child: const Icon(
            Icons.account_balance,
            color: Colors.white,
            size: 24,
          ),
        );
      case PaymentMethod.sberbank:
        return Container(
          width: 40,
          height: 40,
          decoration: BoxDecoration(
            color: Colors.green.shade600,
            borderRadius: BorderRadius.circular(8),
          ),
          child: const Icon(
            Icons.account_balance,
            color: Colors.white,
            size: 24,
          ),
        );
    }
  }

  String _getPaymentMethodName(PaymentMethod method) {
    switch (method) {
      case PaymentMethod.stripe:
        return '–ë–∞–Ω–∫–æ–≤—Å–∫–∞—è –∫–∞—Ä—Ç–∞';
      case PaymentMethod.paypal:
        return 'PayPal';
      case PaymentMethod.yookassa:
        return '–ÆKassa';
      case PaymentMethod.sberbank:
        return '–°–±–µ—Ä–±–∞–Ω–∫';
    }
  }

  String _getPaymentMethodDescription(PaymentMethod method) {
    switch (method) {
      case PaymentMethod.stripe:
        return 'Visa, MasterCard, –ú–ò–†';
      case PaymentMethod.paypal:
        return 'PayPal –∏ –∫—Ä–µ–¥–∏—Ç–Ω—ã–µ –∫–∞—Ä—Ç—ã';
      case PaymentMethod.yookassa:
        return '–ë–∞–Ω–∫–æ–≤—Å–∫–∏–µ –∫–∞—Ä—Ç—ã –∏ —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω—ã–µ –¥–µ–Ω—å–≥–∏';
      case PaymentMethod.sberbank:
        return '–°–ë–ü –∏ –∫–∞—Ä—Ç—ã –°–±–µ—Ä–±–∞–Ω–∫–∞';
    }
  }
}
```

## üîí –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å

### 1. üõ°Ô∏è –ó–∞—â–∏—Ç–∞ –¥–∞–Ω–Ω—ã—Ö

#### 1.1 –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
```dart
// lib/services/encryption_service.dart
import 'package:encrypt/encrypt.dart';
import 'dart:convert';

class EncryptionService {
  static final _encrypter = Encrypt(Encrypter(AES(Key.fromSecureRandom(32))));
  
  /// –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
  static String encrypt(String data) {
    final encrypted = _encrypter.encrypt(data, iv: IV.fromSecureRandom(16));
    return encrypted.base64;
  }
  
  /// –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
  static String decrypt(String encryptedData) {
    final encrypted = Encrypted.fromBase64(encryptedData);
    return _encrypter.decrypt(encrypted, iv: IV.fromSecureRandom(16));
  }
  
  /// –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã
  static String encryptCard(String cardNumber) {
    // –ú–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã (–ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 4 —Ü–∏—Ñ—Ä—ã)
    if (cardNumber.length >= 4) {
      final lastFour = cardNumber.substring(cardNumber.length - 4);
      return '**** **** **** $lastFour';
    }
    return cardNumber;
  }
}
```

#### 1.2 –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
```dart
// lib/services/payment_validation_service.dart
class PaymentValidationService {
  /// –í–∞–ª–∏–¥–∞—Ü–∏—è –Ω–æ–º–µ—Ä–∞ –∫–∞—Ä—Ç—ã
  static bool isValidCardNumber(String cardNumber) {
    // –£–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –¥–µ—Ñ–∏—Å–æ–≤
    final cleanNumber = cardNumber.replaceAll(RegExp(r'[\s-]'), '');
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª–∏–Ω—ã
    if (cleanNumber.length < 13 || cleanNumber.length > 19) {
      return false;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ü–∏—Ñ—Ä—ã
    if (!RegExp(r'^\d+$').hasMatch(cleanNumber)) {
      return false;
    }
    
    // –ê–ª–≥–æ—Ä–∏—Ç–º –õ—É–Ω–∞
    return _luhnCheck(cleanNumber);
  }
  
  /// –ê–ª–≥–æ—Ä–∏—Ç–º –õ—É–Ω–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–æ–º–µ—Ä–∞ –∫–∞—Ä—Ç—ã
  static bool _luhnCheck(String cardNumber) {
    int sum = 0;
    bool alternate = false;
    
    for (int i = cardNumber.length - 1; i >= 0; i--) {
      int digit = int.parse(cardNumber[i]);
      
      if (alternate) {
        digit *= 2;
        if (digit > 9) {
          digit = (digit % 10) + 1;
        }
      }
      
      sum += digit;
      alternate = !alternate;
    }
    
    return sum % 10 == 0;
  }
  
  /// –í–∞–ª–∏–¥–∞—Ü–∏—è CVV
  static bool isValidCVV(String cvv) {
    return RegExp(r'^\d{3,4}$').hasMatch(cvv);
  }
  
  /// –í–∞–ª–∏–¥–∞—Ü–∏—è —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è
  static bool isValidExpiryDate(String expiryDate) {
    final regex = RegExp(r'^(0[1-9]|1[0-2])\/([0-9]{2})$');
    if (!regex.hasMatch(expiryDate)) {
      return false;
    }
    
    final parts = expiryDate.split('/');
    final month = int.parse(parts[0]);
    final year = int.parse('20${parts[1]}');
    
    final now = DateTime.now();
    final expiry = DateTime(year, month + 1, 0); // –ü–æ—Å–ª–µ–¥–Ω–∏–π –¥–µ–Ω—å –º–µ—Å—è—Ü–∞
    
    return expiry.isAfter(now);
  }
}
```

## üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞

### 1. üìà –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–µ–π

#### 1.1 –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π
```dart
// lib/services/payment_analytics_service.dart
import 'package:firebase_analytics/firebase_analytics.dart';

class PaymentAnalyticsService {
  static final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;
  
  /// –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –Ω–∞—á–∞–ª–∞ –ø–ª–∞—Ç–µ–∂–∞
  static Future<void> trackPaymentStarted({
    required PaymentMethod method,
    required double amount,
    required String currency,
  }) async {
    await _analytics.logEvent(
      name: 'payment_started',
      parameters: {
        'payment_method': method.name,
        'amount': amount,
        'currency': currency,
      },
    );
  }
  
  /// –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞
  static Future<void> trackPaymentCompleted({
    required PaymentMethod method,
    required double amount,
    required String currency,
    required String paymentId,
  }) async {
    await _analytics.logEvent(
      name: 'payment_completed',
      parameters: {
        'payment_method': method.name,
        'amount': amount,
        'currency': currency,
        'payment_id': paymentId,
      },
    );
  }
  
  /// –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –Ω–µ—É–¥–∞—á–Ω–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞
  static Future<void> trackPaymentFailed({
    required PaymentMethod method,
    required double amount,
    required String currency,
    required String error,
  }) async {
    await _analytics.logEvent(
      name: 'payment_failed',
      parameters: {
        'payment_method': method.name,
        'amount': amount,
        'currency': currency,
        'error': error,
      },
    );
  }
}
```

## üéØ –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏

### 1. ‚úÖ –ì–æ—Ç–æ–≤–æ
- ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Stripe
- ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è PayPal
- ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –ÆKassa
- ‚úÖ –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–∏—Å –ø–ª–∞—Ç–µ–∂–µ–π
- ‚úÖ UI –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
- ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å

### 2. üîÑ –í –ø—Ä–æ—Ü–µ—Å—Å–µ
- üîÑ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–π
- üîÑ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ webhook'–æ–≤
- üîÑ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø–ª–∞—Ç–µ–∂–µ–π

### 3. üìã –ü–ª–∞–Ω–∏—Ä—É–µ—Ç—Å—è
- üìã –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –°–±–µ—Ä–±–∞–Ω–∫–∞
- üìã –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç
- üìã –ú–æ–±–∏–ª—å–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏
- üìã –ü–æ–¥–ø–∏—Å–∫–∏ –∏ —Ä–µ–≥—É–ª—è—Ä–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏

## üéâ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–ü–ª–∞—Ç–µ–∂–Ω—ã–µ —à–ª—é–∑—ã –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω—ã —Å:
- ‚úÖ **Stripe** –¥–ª—è –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π
- ‚úÖ **PayPal** –¥–ª—è –º–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π
- ‚úÖ **–ÆKassa** –¥–ª—è —Ä–æ—Å—Å–∏–π—Å–∫–æ–≥–æ —Ä—ã–Ω–∫–∞
- ‚úÖ **–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–º API** –¥–ª—è –≤—Å–µ—Ö –º–µ—Ç–æ–¥–æ–≤
- ‚úÖ **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å—é** –Ω–∞ –≤—ã—Å–æ–∫–æ–º —É—Ä–æ–≤–Ω–µ
- ‚úÖ **–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º** –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–æ–π

**–ì–æ—Ç–æ–≤–æ –∫ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø–ª–∞—Ç–µ–∂–µ–π –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ!** üöÄ

---
**–°–ª–µ–¥—É—é—â–∏–π —ç—Ç–∞–ø**: –ù–∞—Å—Ç—Ä–æ–π–∫–∞ email —Å–µ—Ä–≤–∏—Å–∞
